!$IFRAD2
      SUBROUTINE IFRAD2(AA,II,LL,IARCNO,LRDIFF,LOAD,IFFHDR,FFBUF)
!********1*********2*********3*********4*********5*********6*********7**
! IFRAD2           00/00/00            0000.0    PGMR - B. EDDY
!
! FUNCTION:  CONTROL MOVEMENT OF ARC DYNAMIC ARRAY INFORMATION
!            FOR GROUP #2 - INTERPOLATION ARRAYS
!            AS FOLLOWS:
!            1. FROM INTERFACE FILE TO EXTENDED VIRTUAL MEMORY(VM)
!            2. FROM EXTENDED VIRTUAL MEMORY TO ARC DYNAMIC ARRAYS
!            3. FROM ARC DYNAMIC ARRAYS TO EXTENDED VITUAL MEMORY
!
!
! I/O PARAMETERS:
!
!   NAME    I/O  A/S   DESCRIPTION OF PARAMETERS
!   ------  ---  ---   ------------------------------------------------
!   AA      I/O   A    REAL DYNAMIC ARRAY
!   II      I/O   A    INTEGER DYNAMIC ARRAY
!   LL      I/O   A    LOGICAL DYNAMIC ARRAY
!   IARCNO   I    S    CURRENT ARC NUMBER
!   LRDIFF   I    S    FLAG USED TO CONTROL READING/LOADING
!                      = T READ IFF & STORE IN VIRTUAL MEMORY
!                      = F MOVE FROM EXTENDED VIRTUAL MEMORY TO
!                          ARC DYNAMIC ARRAYS OR VICE VERSA AS
!                          INDICATED BY "LOAD"
!   LOAD     I    S    CONTROLS LOADING/UNLOADING OF INFORMATION
!                      = T LOAD FROM EXT. VM TO ARC DYNAMIC ARRAYS
!                      = F UNLOAD FROM DYNAMIC ARRAYS TO EXT. VM
!   IFFHDR   I    A    SCRATCH ARRAY USED FOR HEADER INFORMATION
!   FFBUF    I    A    SCRATCH ARRAY USED TO HOLD REAL DATA PRIOR
!                      TO CONVERSION TO PROPER IIE REPRESENTATION
!
! COMMENTS:     INTERFACE FORMAT #2 USED:
!
! INTEGER  HEADER RECORD  - WITH IFFHDR(5)=0 INDICATING LENGTHS RECORDS
!                           FOLLOWS
! INTEGER LENGTHS RECORD  - CONTAINING IFFHDR(4) WORDS. THE FIRST
!                           IFFHDR(4)-1 WORDS ARE LENGTHS OF DATA
!                           RECORDS. THE LAST WORD IS THE SUM OF LENGTHS
!            DATA RECORDS - IFFHDR(4)-1  DATA RECORDS. DATA RECORDS ARE
!                           OF THE TYPE INDICATED IN IFFHDR(3)
!
! COMMENTS:   TO OUTPUT ADDITIONAL RECORDS IN THIS ROUTINE
!             1. INCREMENT NRECS AND CALCULATE LENGTH OF RECORD TO BE
!                OUTPUT
!             2. ADD WRITE STATEMENT FOR OUTPUTTING DATA RECORDS
!                (IF LENGTH IS ZERO A  RECORD CONTAINING A ZERO MUST
!                BE OUTPUT)
!             3. FOR INTEGER AND LOGICAL DATA SUBROUTINE CYBINT MUST
!                BE CALLED TO CONVERT INTEGERS (AND LOGICALS) TO THE
!                CORRECT REPRESENTATION FOR THE COMPUTER IIE WILL
!                BE RUNNING ON
!
!********1*********2*********3*********4*********5*********6*********7**
      IMPLICIT DOUBLE PRECISION (A-H,O-Z),LOGICAL(L)
      SAVE
!
      COMMON/CIFF  /IFHEAD,IFLNTH,IFBUFL,IFBUFR,KDYNHD,KDYNLN,          &
     &              KDYNIF,KDYNFF,NXCIFF
      COMMON/CONTRL/LSIMDT,LOBS  ,LORB  ,LNOADJ,LNADJL,LORFST,LORLST,   &
     &              LORALL,LORBOB,LOBFST,LOBLST,LOBALL,LPREPO,LORBVX,   &
     &              LORBVK,LACC3D,LSDATA,LCUTOT,LACCEL,LDYNAC,LFRCAT,   &
     &              LNIAU, NXCONT
      COMMON/CORA02/KFSCTB,KFSCTC,KFSCTE,KDSECT,                        &
     &              KFSECT,KS    ,KCIP  ,KCIV  ,                        &
     &       KXTN  ,KXSM  ,KXTK  ,KXSJ  ,KXTI  ,KXTKP ,                 &
     &       KVTN  ,KVSM  ,KVTK  ,KVSJ  ,KVTI  ,KVTKP ,                 &
     &       KSATLT,KSATLN,KSATH ,KCOSTH,KSINTH,                        &
     &       KPXPFM,KPXPFK,KPXPFJ,KTRBF ,KFSTRC,                        &
     &       KFSTRE,KDSCTR,KFSCVS,KXSMBF,KXSKBF,KXSJBF,                 &
     &       KRSSV1,KRSSV2,KRSSV3,KTPMES,KACOEF,KACTIM,                 &
     &       KXTNPC,KXSMPC,KXTKPC,KXSJPC,KXTIPC,KXTKPP,                 &
     &       KRLRNG,KASTO,KASTP,NXCA02
      COMMON/CORI02/KNTIME,KMJSTB,KMJSTC,KMJSTE,KISECT,                 &
     &              KINDH ,KNMH  ,KIVSAT,KIPXPF,KNTRTM,KMSTRC,          &
     &              KMSTRE,KISCTR,KISATR,KITRUN,KTRTMB,KTRTMC,          &
     &              KMJDVS,KNTMVM,NXCI02
      COMMON/CORL02/KLNDTT,KLWSTR,KLNDTR,KLEVMF,KLTPMS,NXCL02
      COMMON/CVIEW /IOUT6 ,ILINE6,IPAGE6,MLINE6,                        &
     &              IOUT8 ,ILINE8,IPAGE8,MLINE8,                        &
     &              IOUT9 ,ILINE9,IPAGE9,MLINE9,                        &
     &              IOUT10,ILIN10,IPAG10,MLIN10,                        &
     &              IOUT15,ILIN15,IPAG15,MLIN15,                        &
     &              IOUT16,ILIN16,IPAG16,MLIN16,                        &
     &              IOUT7 ,NXCVUE
      COMMON/DYNPTR/KDEPHM,KDEPH2,KDAHDR(3,9),KDYNAP(3,9,2),KDNEXT(3),  &
     &NXDYNP
      COMMON/UNITS/IUNT11,IUNT12,IUNT13,IUNT19,IUNT30,IUNT71,IUNT72,    &
     &             IUNT73,IUNT05,IUNT14,IUNT65,IUNT88,IUNT21,IUNT22,    &
     &             IUNT23,IUNT24,IUNT25,IUNT26
!
      DIMENSION AA(1)
      DIMENSION FFBUF(IFBUFR)
      DIMENSION IFFHDR(IFHEAD)
      DIMENSION II(1)
      DIMENSION LL(1)
!
      DATA IBLOCK/60/,IGROUP/2/
!
!**********************************************************************
! START OF EXECUTABLE CODE ********************************************
!**********************************************************************
      IGP1=IGROUP+1
! DETERMINE IF READING DATA FROM INTERFACE FILE
      IF(.NOT.LRDIFF) GO TO 5000
!**********************************************************************
! READ HEADER RECORD FOR REAL DATA
!**********************************************************************
      ITYPE=1
      CALL BINRD(IUNT11,IFFHDR,IFHEAD)
! VERIFY BLOCK NO.,GROUP NUMBER AND DATA TYPE
      IF(IFFHDR(1).NE.IBLOCK .OR. IFFHDR(2).NE.IGROUP .OR.              &
     &   IFFHDR(3).NE.ITYPE) GO TO 60150
      NRECS1=IFFHDR(4)
      NRECS =NRECS1-1
! STORE NRECS1 IN VIRTUAL MEMORY
      IPTHDR=KDAHDR(ITYPE,IGP1)
      II(IPTHDR)=NRECS1
!**********************************************************************
! READ LENGTHS RECORD FOR REAL DATA-STORE IN VIRTUAL MEMORY
!**********************************************************************
      CALL BINRD(IUNT11,II(IPTHDR+1),NRECS1)
! LAST WORD READ IS SUM OF THE LENGTHS OF THE DATA RECORDS
      NWORDS=II(IPTHDR+NRECS1)
!**********************************************************************
! READ REAL DATA RECORDS AN@ STORE IN VIRTUAL MEMORY
!**********************************************************************
      IF(NRECS.EQ.0) GO TO 1000
      IPTR=KDYNAP(ITYPE,IGP1,1)+(IARCNO-1)*KDYNAP(ITYPE,IGP1,2)
      IPTSTR=IPTR
      DO 200 IREC=1,NRECS
      NX=II(IPTHDR+IREC)
      IF(NX.GT.IFBUFR) GO TO 60300
      CALL BINRD2(IUNT11,FFBUF,NX )
      IF(NX.GT.0) CALL Q9ICLA(FFBUF,AA(IPTR),NX,ISTAT)
      IF(ISTAT.NE.0) GO TO 60350
      IPTR=IPTR+NX
  200 END DO
!
! TEST IF CORRECT NUMBER OF WORDS READ
!
      IF(NWORDS.NE. IPTR-IPTSTR) GO TO 60220
!**********************************************************************
! READ HEADER RECORD FOR INTEGER DATA
!**********************************************************************
 1000 ITYPE=2
      CALL BINRD(IUNT11,IFFHDR,IFHEAD)
! VERIFY BLOCK NO.,GROUP NUMBER AND DATA TYPE
      IF(IFFHDR(1).NE.IBLOCK .OR. IFFHDR(2).NE.IGROUP .OR.              &
     &   IFFHDR(3).NE.ITYPE) GO TO 60150
      NRECS1=IFFHDR(4)
      NRECS = NRECS1-1
! STORE NRECS1 IN VIRTUAL MEMORY
      IPTHDR=KDAHDR(ITYPE,IGP1)
      II(IPTHDR)=NRECS1
!**********************************************************************
! READ LENGTHS RECORD FOR INTEGER DATA-STORE IN VIRTUAL MEMORY
!**********************************************************************
      CALL BINRD(IUNT11,II(IPTHDR+1),NRECS1)
      NWORDS=II(IPTHDR+NRECS1)
!**********************************************************************
! READ INTEGER DATA RECORDS AND STORE IN VIRTUAL MEMORY
!**********************************************************************
      IF(NRECS.EQ.0) GO TO 2000
      IPTR=KDYNAP(ITYPE,IGP1,1)+(IARCNO-1)*KDYNAP(ITYPE,IGP1,2)
      IPTSTR=IPTR
      DO 1200 IREC=1,NRECS
      NX=II(IPTHDR+IREC)
      CALL BINRD(IUNT11,II(IPTR),NX)
      IPTR=IPTR+NX
 1200 END DO
!
! TEST IF CORRECT NUMBER OF WORDS READ
!
      IF(NWORDS.NE.IPTR-IPTSTR) GO TO 60220
!**********************************************************************
! READ HEADER RECORD FOR LOGICAL DATA
!**********************************************************************
 2000 ITYPE=3
      CALL BINRD(IUNT11,IFFHDR,IFHEAD)
! VERIFY BLOCK NO.,GROUP NUMBER AND DATA TYPE
      IF(IFFHDR(1).NE.IBLOCK .OR. IFFHDR(2).NE.IGROUP .OR.              &
     &   IFFHDR(3).NE.ITYPE) GO TO 60150
      NRECS1=IFFHDR(4)
      NRECS = NRECS1-1
! STORE NRECS1 IN VIRTUAL MEMORY
      IPTHDR=KDAHDR(ITYPE,IGP1)
      II(IPTHDR)=NRECS1
!**********************************************************************
! READ LENGTHS RECORD FOR LOGICAL DATA-STORE IN VIRTUAL MEMORY
!**********************************************************************
      CALL BINRD(IUNT11,II(IPTHDR+1),NRECS1)
      NWORDS=II(IPTHDR+NRECS1)
!**********************************************************************
! READ LOGICAL DATA RECORDS AND STORE IN VIRTUAL MEMORY
!**********************************************************************
      IF(NRECS.EQ.0) GO TO 3000
      IPTR=KDYNAP(ITYPE,IGP1,1)+(IARCNO-1)*KDYNAP(ITYPE,IGP1,2)
      IPTSTR=IPTR
      DO 2200 IREC=1,NRECS
      NX=II(IPTHDR+IREC)
      CALL BINRDL(IUNT11,LL(IPTR),NX)
      IPTR=IPTR+NX
 2200 END DO
! TEST IF CORRECT NUMBER OF WORDS READ
      IF(NWORDS.NE. IPTR-IPTSTR) GO TO 60220
 3000 CONTINUE
!**********************************************************************
      RETURN
!**********************************************************************
!**********************************************************************
! LOAD INFORMATION FROM EXTENDED VIRTUAL MEM. TO ARC DYNAMIC ARRAYS OR
! UNLOAD INFORMATION FROM DYNAMIC ARRAYS TO EXTENDED VIRTUAL MEMORY
!**********************************************************************
!**********************************************************************
!
!**********************************************************************
! LOAD/UNLOAD REAL DATA
!**********************************************************************
 5000 ITYPE=1
      IPTHDR=KDAHDR(ITYPE,IGP1)
      NRECS1=II(IPTHDR)
      NRECS =NRECS1-1
      NWORDS=II(IPTHDR+NRECS1)
      IPTR=KDYNAP(ITYPE,IGP1,1)+(IARCNO-1)*KDYNAP(ITYPE,IGP1,2)
      IPTSTR=IPTR
      IREC=0
! KFSCTB
      IREC=IREC+1
      NX=II(IPTHDR+IREC)
      CALL MOVER(AA(IPTR),AA(KFSCTB),NX,LOAD)
      IPTR=IPTR+NX
! KFSCTC
      IREC=IREC+1
      NX=II(IPTHDR+IREC)
      CALL MOVER(AA(IPTR),AA(KFSCTC),NX,LOAD)
      IPTR=IPTR+NX
! KFSCTE
      IREC=IREC+1
      NX=II(IPTHDR+IREC)
      CALL MOVER(AA(IPTR),AA(KFSCTE),NX,LOAD)
      IPTR=IPTR+NX
! KDSECT
      IREC=IREC+1
      NX=II(IPTHDR+IREC)
      CALL MOVER(AA(IPTR),AA(KDSECT),NX,LOAD)
      IPTR=IPTR+NX
! KFSTRC
      IREC=IREC+1
      NX=II(IPTHDR+IREC)
      CALL MOVER(AA(IPTR),AA(KFSTRC),NX,LOAD)
      IPTR=IPTR+NX
! KFSTRE
      IREC=IREC+1
      NX=II(IPTHDR+IREC)
      CALL MOVER(AA(IPTR),AA(KFSTRE),NX,LOAD)
      IPTR=IPTR+NX
! KDSCTR
      IREC=IREC+1
      NX=II(IPTHDR+IREC)
      CALL MOVER(AA(IPTR),AA(KDSCTR),NX,LOAD)
      IPTR=IPTR+NX
!
! TEST IF CORRECT NUMBER OF DATA RECORDS RELOADED
!
      IF(IREC.NE.NRECS) GO TO 60200
! TEST IF CORRECT NUMBER OF WORDS RELOADED
      IF(NWORDS.NE.IPTR-IPTSTR) GO TO 60220
!**********************************************************************
! LOAD/UNLOAD INTEGER DATA
!**********************************************************************
      ITYPE=2
      IPTHDR=KDAHDR(ITYPE,IGP1)
      NRECS1=II(IPTHDR)
      NRECS =NRECS1-1
      NWORDS=II(IPTHDR+NRECS1)
      IPTR=KDYNAP(ITYPE,IGP1,1)+(IARCNO-1)*KDYNAP(ITYPE,IGP1,2)
      IPTSTR=IPTR
      IREC=0
! KNTIME
      IREC=IREC+1
      NX=II(IPTHDR+IREC)
      CALL MOVEI(II(IPTR),II(KNTIME),NX,LOAD)
      IPTR=IPTR+NX
! KMJSTB
      IREC=IREC+1
      NX=II(IPTHDR+IREC)
      CALL MOVEI(II(IPTR),II(KMJSTB),NX,LOAD)
      IPTR=IPTR+NX
! KMJSTC
      IREC=IREC+1
      NX=II(IPTHDR+IREC)
      CALL MOVEI(II(IPTR),II(KMJSTC),NX,LOAD)
      IPTR=IPTR+NX
! KMJSTE
      IREC=IREC+1
      NX=II(IPTHDR+IREC)
      CALL MOVEI(II(IPTR),II(KMJSTE),NX,LOAD)
      IPTR=IPTR+NX
! KISECT
      IREC=IREC+1
      NX=II(IPTHDR+IREC)
      CALL MOVEI(II(IPTR),II(KISECT),NX,LOAD)
      IPTR=IPTR+NX
! KNTRTM
      IREC=IREC+1
      NX=II(IPTHDR+IREC)

! TO KEEP INTEGRATOR IN SEQUENCE SET NTRTM ARRAY TO 1 SO THAT
! TRAGEN IS CALLED FOR ONLY ONE EPOCH AT A TIME
       IF(LOBS.AND.NX.GT.0) THEN
         DO IQ=1,NX
           II(KNTRTM-1+IQ)=1
         ENDDO
       ENDIF

      CALL MOVEI(II(IPTR),II(KNTRTM),NX,LOAD)

! TO KEEP INTEGRATOR IN SEQUENCE SET NTRTM ARRAY TO 1 SO THAT
! TRAGEN IS CALLED FOR ONLY ONE EPOCH AT A TIME
       IF(LOBS.AND.NX.GT.0) THEN
         DO IQ=1,NX
           II(KNTRTM-1+IQ)=1
         ENDDO
       ENDIF

      IPTR=IPTR+NX
! KMSTRC
      IREC=IREC+1
      NX=II(IPTHDR+IREC)
      CALL MOVEI(II(IPTR),II(KMSTRC),NX,LOAD)
      IPTR=IPTR+NX
! KMSTRE
      IREC=IREC+1
      NX=II(IPTHDR+IREC)
      CALL MOVEI(II(IPTR),II(KMSTRE),NX,LOAD)
      IPTR=IPTR+NX
! KISCTR
      IREC=IREC+1
      NX=II(IPTHDR+IREC)
      CALL MOVEI(II(IPTR),II(KISCTR),NX,LOAD)
      IPTR=IPTR+NX
! KISATR
      IREC=IREC+1
      NX=II(IPTHDR+IREC)
      CALL MOVEI(II(IPTR),II(KISATR),NX,LOAD)
      IPTR=IPTR+NX
! KITRUN
      IREC=IREC+1
      NX=II(IPTHDR+IREC)
      CALL MOVEI(II(IPTR),II(KITRUN),NX,LOAD)
      IPTR=IPTR+NX
!
! TEST IF CORRECT NUMBER OF DATA RECORDS RELOADED
!
      IF(IREC.NE.NRECS) GO TO 60200
! TEST IF CORRECT NUMBER OF WORDS RELOADED
      IF(NWORDS .NE. IPTR-IPTSTR) GO TO 60220
!**********************************************************************
! LOAD/UNLOAD LOGICAL DATA RECORDS
!**********************************************************************
      ITYPE=3
      IPTHDR=KDAHDR(ITYPE,IGP1)
      NRECS1=II(IPTHDR)
      NRECS =NRECS1-1
      NWORDS=II(IPTHDR+NRECS1)
      IPTR=KDYNAP(ITYPE,IGP1,1)+(IARCNO-1)*KDYNAP(ITYPE,IGP1,2)
      IPTSTR=IPTR
      IREC=0
! KLNDTT
      IREC=IREC+1
      NX=II(IPTHDR+IREC)
      CALL MOVEL(LL(IPTR),LL(KLNDTT),NX,LOAD)
      IPTR=IPTR+NX
! KLWSTR
      IREC=IREC+1
      NX=II(IPTHDR+IREC)
      CALL MOVEL(LL(IPTR),LL(KLWSTR),NX,LOAD)
      IPTR=IPTR+NX
! KLNDTR
      IREC=IREC+1
      NX=II(IPTHDR+IREC)
      CALL MOVEL(LL(IPTR),LL(KLNDTR),NX,LOAD)
      IPTR=IPTR+NX
!
! TEST IF CORRECT NUMBER OF DATA RECORDS RELOADED
!
      IF(IREC.NE.NRECS) GO TO 60200
! TEST IF CORRECT NUMBER OF WORDS RELOADED
      IF(NWORDS.NE. IPTR-IPTSTR ) GO TO 60220
!**********************************************************************
! NORMAL END OF ROUTINE
!**********************************************************************
      RETURN
!**********************************************************************
! ERROR PROCESSING
!**********************************************************************
! NUMBER OF OUTPUT RECORDS EXCEEDS LENGTHS RECORD
60150 WRITE(IOUT6,80150) IBLOCK,IGROUP,ITYPE,(IFFHDR(J),J=1,10)
      WRITE(IOUT6,89999)
      STOP
! NUMBER OF RECORDS READ/RELOADED DISAGREES WITH NUMBER EXPECTED
60200 WRITE(IOUT6,80200) IARCNO,ITYPE,IREC,NRECS
      WRITE(IOUT6,89999)
      STOP
! NUMBER OF WORDS READ/RELOADED DISAGREES WITH NUMBER OF WORDS EXPECTED
60220 WRITE(IOUT6,80220) IARCNO,ITYPE,NWORDS,IPTR,IPTSTR
      WRITE(IOUT6,89999)
      STOP
! INTEGER OR LOGICAL RECORD EXCEEDS BUFFER SPACE AVAILABLE
60300 WRITE(IOUT6,80300) IARCNO,ITYPE,IREC,NX,IFBUFR
      WRITE(IOUT6,89999)
      STOP
! FLOATING POINT CONVERSION PROBLEM
60350 WRITE(IOUT6,80350) ISTAT
      WRITE(IOUT6,89999)
      STOP
80150 FORMAT(1X,'BLOCK NUMBER,GROUP NUMBER OR TYPE IS INCORRECT ',      &
     & 13I5)
80200 FORMAT(1X,'NUMBER OF RECORDS READ/RELOADED DISAGREES WITH NUMBER',&
     &'EXPECTED. ARC NO.,RECORD TYPE,RECORD NUMBER, AND NO. OF RECORDS',&
     &'FOLLOWS'/5X,4I8)
80220 FORMAT(1X,'NUMBER OF WORDS READ/RELOADED DISAGREES WITH NUMBER',&
     &'EXPECTED. '/1X,'ARC NUMBER,RECORD TYPE,NUMBER OF WORDS,STARTING',&
     &'POINTER,AND ENDING POINTER FOLLOW'/1X,6I8)
80300 FORMAT(1X,'INPUT RECORD EXCEEDS BUFFER SPACE - (ARC NO.,RECORD',&
     &'TYPE,RECORD NUMBER,NO. OF WORDS,BUFFER SPACE )'/10X,5I8)
80350 FORMAT(1X,'FLOATING POINT CONVERSION PROBLEM - ISTAT = ',I5)
89999 FORMAT(1X,'EXECUTION TERMINATING IN SUBROUTINE IFRAD2 ')
      END
