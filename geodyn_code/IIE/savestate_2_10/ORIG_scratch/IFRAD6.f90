!$IFRAD6
      SUBROUTINE IFRAD6(AA,II,LL,IARCNO,LRDIFF,LOAD,IFFHDR,FFBUF)
!********1*********2*********3*********4*********5*********6*********7**
! IFRAD6           84/03/12            0000.0    PGMR - B. EDDY
!
! FUNCTION:  CONTROLS MOVEMENT OF ARC DYNAMIC ARRAY INFORMATION
!            FOR GROUP #6 - ESTIMATION ARRAYS
!            AS FOLLOWS:
!            1. FROM INTERFACE FILE TO EXTENDED VIRTUAL MEMORY(VM)
!            2. FROM EXTENDED VIRTUAL MEMORY TO ARC DYNAMIC ARRAYS
!            3. FROM ARC DYNAMIC ARRAYS TO EXTENDED VITUAL MEMORY
!
!
! I/O PARAMETERS:
!
!   NAME    I/O  A/S   DESCRIPTION OF PARAMETERS
!   ------  ---  ---   ------------------------------------------------
!   AA      I/O   A    DYNAMIC ARRAY USED FOR REAL DATA
!   II      I/O   A    DYNAMIC ARRAY USED FOR INTEGER DATA
!   LL      I/O   A    DYNAMIC ARRAY USED FOR LOGICAL DATA
!   IARCNO   I    S    CURRENT ARC NUMBER
!   LRDIFF   I    S    FLAG USED TO CONTROL READING/LOADING
!                      = T READ IFF & STORE IN VIRTUAL MEMORY
!                      = F MOVE FROM EXTENDED VIRTUAL MEMORY TO
!                          ARC DYNAMIC ARRAYS OR VICE VERSA AS
!                          INDICATED BY "LOAD"
!   LOAD     I    S    CONTROLS LOADING/UNLOADING OF INFORMATION
!                      = T LOAD FROM EXT. VM TO ARC DYNAMIC ARRAYS
!                      = F UNLOAD FROM DYNAMIC ARRAYS TO EXT. VM
!   IFFHDR   I    A    SCRATCH ARRAY USED FOR HEADER INFORMATION
!   FFBUF    I    A    SCRATCH ARRAY USED TO HOLD REAL DATA PRIOR
!                      TO CONVERSION TO PROPER IIE REPRESENTATION
!
!
! COMMENTS:     INTERFACE FORMAT #2 USED:
!
! INTEGER  HEADER RECORD  - WITH IFFHDR(5)=0 INDICATING LENGTHS RECORDS
!                           FOLLOWS
! INTEGER LENGTHS RECORD  - CONTAINING IFFHDR(4) WORDS. THE FIRST
!                           IFFHDR(4)-1 WORDS ARE LENGTHS OF DATA
!                           RECORDS. THE LAST WORD IS THE SUM OF LENGTHS
!            DATA RECORDS - IFFHDR(4)-1  DATA RECORDS. DATA RECORDS ARE
!                           OF THE TYPE INDICATED IN IFFHDR(3)
!
! COMMENTS:   TO OUTPUT ADDITIONAL RECORDS IN THIS ROUTINE
!             1. INCREMENT NRECS AND CALCULATE LENGTH OF RECORD TO BE
!                OUTPUT
!             2. ADD WRITE STATEMENT FOR OUTPUTTING DATA RECORDS
!                (IF LENGTH IS ZERO A  RECORD CONTAINING A ZERO MUST
!                BE OUTPUT)
!             3. FOR INTEGER AND LOGICAL DATA SUBROUTINE CYBINT MUST
!                BE CALLED TO CONVERT INTEGERS (AND LOGICALS) TO THE
!                CORRECT REPRESENTATION FOR THE COMPUTER IIE WILL
!                BE RUNNING ON
!
!********1*********2*********3*********4*********5*********6*********7**
      IMPLICIT DOUBLE PRECISION (A-H,O-Z),LOGICAL(L)
      SAVE
!
      COMMON/ARCLOA/NEWLEN
      COMMON/CESTIM/MPARM,MAPARM,MAXDIM,MAXFMG,ICLINK,IPROCS,NXCEST
      COMMON/CIFF  /IFHEAD,IFLNTH,IFBUFL,IFBUFR,KDYNHD,KDYNLN,          &
     &              KDYNIF,KDYNFF,NXCIFF
      COMMON/CORA06/KPRMV ,KPNAME,KPRMV0,KPRMVC,KPRMVP,KPRMSG,KPARVR,   &
     &              KPRML0,KPDLTA,KSATCV,KSTACV,KPOLCV,KTIDCV,KSUM1 ,   &
     &              KSUM2 ,KGPNRA,KGPNRM,KPRSG0,KCONDN,KVELCV,          &
     &              KSL2CV,KSH2CV,KTIEOU,KPRMDF,NXCA06
      COMMON/CORI06/KPTRAU,KPTRUA,KNFMG ,KIPTFM,KILNFM,KIGPC ,          &
     &              KIGPS ,KIGPCA,KIGPSA,KIELMT,KMFMG ,KTPGPC,          &
     &              KTPGPS,KTPUC ,KTPUS,                                &
     &              KLINK,KPTFAU,KPTFUA,NXCI06
      COMMON/CORL06/KLBIAS,KLADEL,NXCL06
      COMMON/CVIEW /IOUT6 ,ILINE6,IPAGE6,MLINE6,                        &
     &              IOUT8 ,ILINE8,IPAGE8,MLINE8,                        &
     &              IOUT9 ,ILINE9,IPAGE9,MLINE9,                        &
     &              IOUT10,ILIN10,IPAG10,MLIN10,                        &
     &              IOUT15,ILIN15,IPAG15,MLIN15,                        &
     &              IOUT16,ILIN16,IPAG16,MLIN16,                        &
     &              IOUT7 ,NXCVUE
      COMMON/DYNPTR/KDEPHM,KDEPH2,KDAHDR(3,9),KDYNAP(3,9,2),KDNEXT(3),  &
     &NXDYNP
      COMMON/UNITS/IUNT11,IUNT12,IUNT13,IUNT19,IUNT30,IUNT71,IUNT72,    &
     &             IUNT73,IUNT05,IUNT14,IUNT65,IUNT88,IUNT21,IUNT22,    &
     &             IUNT23,IUNT24,IUNT25,IUNT26
!
      DIMENSION AA(1)
      DIMENSION FFBUF(IFBUFR)
      DIMENSION IFFHDR(IFHEAD)
      DIMENSION II(1)
      DIMENSION LL(1)
!
      DATA IBLOCK/60/,IGROUP/6/,NNRDR/1/
      DATA ONE/1.0D0/
      DATA KK/163798/
      DATA KL/163879/
!
!**********************************************************************
! START OF EXECUTABLE CODE ********************************************
!**********************************************************************
      IGP1=IGROUP+1
! DETERMINE IF READING DATA FROM INTERFACE FILE
      IF(.NOT.LRDIFF) GO TO 5000
!**********************************************************************
! READ HEADER RECORD FOR REAL DATA
!**********************************************************************
      ITYPE=1
      CALL BINRD(IUNT11,IFFHDR,IFHEAD)
! VERIFY BLOCK NO.,GROUP NUMBER AND DATA TYPE
      IF(IFFHDR(1).NE.IBLOCK .OR. IFFHDR(2).NE.IGROUP .OR.              &
     &   IFFHDR(3).NE.ITYPE) GO TO 60150
      NRECS1=IFFHDR(4)
      NRECS =NRECS1-1
! STORE NRECS1 IN VIRTUAL MEMORY
      IPTHDR=KDAHDR(ITYPE,IGP1)
      II(IPTHDR)=NRECS1
!**********************************************************************
! READ LENGTHS RECORD FOR REAL DATA-STORE IN VIRTUAL MEMORY
!**********************************************************************
      CALL BINRD(IUNT11,II(IPTHDR+1),NRECS1)
! LAST WORD READ IS SUM OF THE LENGTHS OF THE DATA RECORDS
      NWORDS=II(IPTHDR+NRECS1)
!**********************************************************************
! READ REAL DATA RECORDS AND STORE IN VIRTUAL MEMORY
!**********************************************************************
      IF(NRECS.EQ.0) GO TO 1000
      IPTR=KDYNAP(ITYPE,IGP1,1)+(IARCNO-1)*KDYNAP(ITYPE,IGP1,2)
      IPTSTR=IPTR
      NRECRD=NRECS-NNRDR
      DO 200 IREC=1,NRECRD
      NX=II(IPTHDR+IREC)
      NXABS=ABS(NX)
      IF(NXABS.GT.IFBUFR) GO TO 60300
      IF(NX.GE.0) THEN
      CALL BINRD2(IUNT11,FFBUF,NXABS )
      IF(NX.GT.0)  CALL Q9ICLA(FFBUF,AA(IPTR),NXABS,ISTAT)
      ELSE
      CALL BINRDC(IUNT11,FFBUF,NXABS)
      CALL MOVER(FFBUF,AA(IPTR),NXABS,.TRUE.)
      ENDIF
! RESET LENGTH TO POSITIVE NUMBER (NEGATIVE INDICATES CHARACTER DATA)
      II(IPTHDR+IREC)=NXABS
      IF(ISTAT.NE.0) GO TO 60350
      IPTR=IPTR+NXABS
  200 END DO
      DO 300 IREC=1,NNRDR
      NX=II(IPTHDR+NRECRD+IREC)
      NXABS=ABS(NX)
      IF(NXABS.GT.IFBUFR) GO TO 60300
!     CALL BINRD2(IUNT11,FFBUF,NXABS )
!     IF(NX.GT.0)  CALL Q9ICLA(FFBUF,AA(IPTR),NXABS,ISTAT)
!     IF(NX.LT.0)  CALL MOVER(FFBUF,AA(IPTR),NXABS,.TRUE.)
! RESET LENGTH TO POSITIVE NUMBER (NEGATIVE INDICATES CHARACTER DATA)
      II(IPTHDR+NRECRD+IREC)=NXABS
!     IF(ISTAT.NE.0) GO TO 60350
      IPTR=IPTR+NXABS
  300 END DO
!
! TEST IF CORRECT NUMBER OF WORDS READ
!
      IF(NWORDS.NE. IPTR-IPTSTR) GO TO 60220
!**********************************************************************
! READ HEADER RECORD FOR INTEGER DATA
!**********************************************************************
 1000 ITYPE=2
      CALL BINRD(IUNT11,IFFHDR,IFHEAD)
! VERIFY BLOCK NO.,GROUP NUMBER AND DATA TYPE
      IF(IFFHDR(1).NE.IBLOCK .OR. IFFHDR(2).NE.IGROUP .OR.              &
     &   IFFHDR(3).NE.ITYPE) GO TO 60150
      NRECS1=IFFHDR(4)
      NRECS = NRECS1-1
! STORE NRECS1 IN VIRTUAL MEMORY
      IPTHDR=KDAHDR(ITYPE,IGP1)
      II(IPTHDR)=NRECS1
!**********************************************************************
! READ LENGTHS RECORD FOR INTEGER DATA-STORE IN VIRTUAL MEMORY
!**********************************************************************
      CALL BINRD(IUNT11,II(IPTHDR+1),NRECS1)
      NWORDS=II(IPTHDR+NRECS1)
!**********************************************************************
! READ INTEGER DATA RECORDS AND STORE IN VIRTUAL MEMORY
!**********************************************************************
      IF(NRECS.EQ.0) GO TO 2000
      IPTR=KDYNAP(ITYPE,IGP1,1)+(IARCNO-1)*KDYNAP(ITYPE,IGP1,2)
      IPTSTR=IPTR
      DO 1200 IREC=1,NRECS
      NX=II(IPTHDR+IREC)
      CALL BINRD(IUNT11,II(IPTR),NX)
      IPTR=IPTR+NX
 1200 END DO
!
! TEST IF CORRECT NUMBER OF WORDS READ
!
      IF(NWORDS.NE.IPTR-IPTSTR) GO TO 60220
!**********************************************************************
! READ HEADER RECORD FOR LOGICAL DATA
!**********************************************************************
 2000 ITYPE=3
      CALL BINRD(IUNT11,IFFHDR,IFHEAD)
! VERIFY BLOCK NO.,GROUP NUMBER AND DATA TYPE
      IF(IFFHDR(1).NE.IBLOCK .OR. IFFHDR(2).NE.IGROUP .OR.              &
     &   IFFHDR(3).NE.ITYPE) GO TO 60150
      NRECS1=IFFHDR(4)
      NRECS = NRECS1-1
! STORE NRECS1 IN VIRTUAL MEMORY
      IPTHDR=KDAHDR(ITYPE,IGP1)
      II(IPTHDR)=NRECS1
!**********************************************************************
! READ LENGTHS RECORD FOR LOGICAL DATA-STORE IN VIRTUAL MEMORY
!**********************************************************************
      CALL BINRD(IUNT11,II(IPTHDR+1),NRECS1)
      NWORDS=II(IPTHDR+NRECS1)
!**********************************************************************
! READ LOGICAL DATA RECORDS AND STORE IN VIRTUAL MEMORY
!**********************************************************************
      IF(NRECS.EQ.0) GO TO 3000
      IPTR=KDYNAP(ITYPE,IGP1,1)+(IARCNO-1)*KDYNAP(ITYPE,IGP1,2)
      IPTSTR=IPTR
      DO 2200 IREC=1,NRECS
      NX=II(IPTHDR+IREC)
      CALL BINRDL(IUNT11,LL(IPTR),NX)
      IPTR=IPTR+NX
 2200 END DO
! TEST IF CORRECT NUMBER OF WORDS READ
      IF(NWORDS.NE. IPTR-IPTSTR) GO TO 60220
 3000 CONTINUE
!**********************************************************************
      RETURN
!**********************************************************************
!**********************************************************************
! LOAD INFORMATION FROM EXTENDED VIRTUAL MEM. TO ARC DYNAMIC ARRAYS OR
! UNLOAD INFORMATION FROM DYNAMIC ARRAYS TO EXTENDED VIRTUAL MEMORY
!**********************************************************************
!**********************************************************************
!
!**********************************************************************
! LOAD/UNLOAD REAL DATA
!**********************************************************************
 5000 ITYPE=1
      IPTHDR=KDAHDR(ITYPE,IGP1)
      NRECS1=II(IPTHDR)
      NRECS =NRECS1-1
      IF(NRECS.EQ.0) GO TO 7000
      NWORDS=II(IPTHDR+NRECS1)
      IPTR=KDYNAP(ITYPE,IGP1,1)+(IARCNO-1)*KDYNAP(ITYPE,IGP1,2)
      IPTSTR=IPTR
      IREC=0
! KPRMV/PARMV
      IREC=IREC+1
      NX=II(IPTHDR+IREC)
      CALL MOVER(AA(IPTR),AA(KPRMV ),NX,LOAD)
      IPTR=IPTR+NX
! KPNAME/PNAME
      IREC=IREC+1
      NX=II(IPTHDR+IREC)
      CALL MOVER(AA(IPTR),AA(KPNAME),NX,LOAD)
      IPTR=IPTR+NX
! KPRMV0/PARMV0
! KPRMVC/PARMVC
! KPRMVP/PARMVP
      IREC=IREC+1
      NX=II(IPTHDR+IREC)
      CALL MOVER(AA(IPTR)  ,AA(KPRMV0),NX,LOAD)
      CALL MOVER(AA(KPRMV0),AA(KPRMVC),NX,LOAD)
      CALL MOVER(AA(KPRMV0),AA(KPRMVP),NX,LOAD)
      IPTR=IPTR+NX
! KPRSG0/PARSG0
      IREC=IREC+1
      NX=II(IPTHDR+IREC)
      CALL MOVER(AA(IPTR),AA(KPRSG0),NX,LOAD)
      IPTR=IPTR+NX
!     IF (NX.LE.0) GO TO 5220
!     DO 5200 J=1,NX
!     J1=J-1
!     AA(KPARVR+J1)=ONE/(AA(KPRSG0+J1)*AA(KPRSG0+J1))
!5200 CONTINUE
!5220 CONTINUE
! KPARVR/PARVAR
      IREC=IREC+1
      NX=II(IPTHDR+IREC)
      CALL MOVER(AA(IPTR),AA(KPARVR),NX,LOAD)
      IPTR=IPTR+NX
! KPRML0/PARML0
      IREC=IREC+1
      NX=II(IPTHDR+IREC)
      CALL MOVER(AA(IPTR),AA(KPRML0),NX,LOAD)
      IPTR=IPTR+NX
! KSATCV/SATCOV
      IREC=IREC+1
      NX=II(IPTHDR+IREC)
      CALL MOVER(AA(IPTR),AA(KSATCV),NX,LOAD)
      IPTR=IPTR+NX
! KSUM1/SUM1
      IREC=IREC+1
      NX=II(IPTHDR+IREC)
      NXX=NX
      IF(NEWLEN.GT.0) NXX=NEWLEN
      CALL MOVER(AA(IPTR),AA(KSUM1),NXX,LOAD)
      IPTR=IPTR+NX
!
! TEST IF CORRECT NUMBER OF DATA RECORDS LOAD/UNLOADED
!
      IF(IREC.NE.NRECS) GO TO 60200
! TEST IF CORRECT NUMBER OF WORDS LOADED/UNLOADED
      IF(NWORDS.NE.IPTR-IPTSTR) GO TO 60220
!**********************************************************************
! LOAD/UNLOAD INTEGER DATA
!**********************************************************************
 7000 ITYPE=2
      IPTHDR=KDAHDR(ITYPE,IGP1)
      NRECS1=II(IPTHDR)
      NRECS =NRECS1-1
      IF(NRECS.LE.0) GO TO 9000
      NWORDS=II(IPTHDR+NRECS1)
      IPTR=KDYNAP(ITYPE,IGP1,1)+(IARCNO-1)*KDYNAP(ITYPE,IGP1,2)
      IPTSTR=IPTR
      IREC=0
! KPTRAU/IPTRAU
      IREC=IREC+1
      NX=II(IPTHDR+IREC)
      CALL MOVEI(II(IPTR),II(KPTRAU),NX,LOAD)
      IPTR=IPTR+NX
! KPTRUA/IPTRUA
      IREC=IREC+1
      NX=II(IPTHDR+IREC)
      CALL MOVEI(II(IPTR),II(KPTRUA),NX,LOAD)
      IPTR=IPTR+NX
! KMFMG/MFMG CHANGED FROM KNFMG 7/16/85 WFE
      IREC=IREC+1
      NX=II(IPTHDR+IREC)
      CALL MOVEI(II(IPTR),II(KMFMG),NX,LOAD)
      IPTR=IPTR+NX
! KIPTFM/IPTFMG
      IREC=IREC+1
      NX=II(IPTHDR+IREC)
      CALL MOVEI(II(IPTR),II(KIPTFM),NX,LOAD)
      IPTR=IPTR+NX
! KILNFM/ILNFMG
      IREC=IREC+1
      NX=II(IPTHDR+IREC)
      CALL MOVEI(II(IPTR),II(KILNFM),NX,LOAD)
      IPTR=IPTR+NX
! KIGPCA/IGPCA
      IREC=IREC+1
      NX=II(IPTHDR+IREC)
      CALL MOVEI(II(IPTR),II(KIGPCA),NX,LOAD)
      IPTR=IPTR+NX
! KIGPSA/IGPSA
      IREC=IREC+1
      NX=II(IPTHDR+IREC)
      CALL MOVEI(II(IPTR),II(KIGPSA),NX,LOAD)
      IPTR=IPTR+NX
! KIELMT/IELMTP
      IREC=IREC+1
      NX=II(IPTHDR+IREC)
      CALL MOVEI(II(IPTR),II(KIELMT),NX,LOAD)
      IPTR=IPTR+NX
!
! TEST IF CORRECT NUMBER OF DATA RECORDS LOADED/UNLOADED
!
      IF(IREC.NE.NRECS) GO TO 60200
! TEST IF CORRECT NUMBER OF WORDS LOADED/UNLOADED
      IF(NWORDS .NE. IPTR-IPTSTR) GO TO 60220
!**********************************************************************
! LOAD/UNLOAD LOGICAL DATA RECORDS
!**********************************************************************
 9000 ITYPE=3
      IPTHDR=KDAHDR(ITYPE,IGP1)
      NRECS1=II(IPTHDR)
      NRECS =NRECS1-1
      IF(NRECS.LE.0) GO TO 60000
      NWORDS=II(IPTHDR+NRECS1)
      IPTR=KDYNAP(ITYPE,IGP1,1)+(IARCNO-1)*KDYNAP(ITYPE,IGP1,2)
      IPTSTR=IPTR
      IREC=0
! KLBIAS
      IREC=IREC+1
      NX=II(IPTHDR+IREC)
      CALL MOVEL(LL(IPTR),LL(KLBIAS),NX,LOAD)
      IPTR=IPTR+NX
! KLADEL
      IREC=IREC+1
      NX=II(IPTHDR+IREC)
      CALL MOVEL(LL(IPTR),LL(KLADEL),NX,LOAD)
      IPTR=IPTR+NX
!
! TEST IF CORRECT NUMBER OF DATA RECORDS LOADED/UNLOADED
!
      IF(IREC.NE.NRECS) GO TO 60200
! TEST IF CORRECT NUMBER OF WORDS LOADED/UNLOADED
      IF(NWORDS.NE. IPTR-IPTSTR ) GO TO 60220
!**********************************************************************
! NORMAL END OF ROUTINE
!**********************************************************************
60000 RETURN
!**********************************************************************
! ERROR PROCESSING
!**********************************************************************
! NUMBER OF OUTPUT RECORDS EXCEEDS LENGTHS RECORD
60150 WRITE(IOUT6,80150) IBLOCK,IGROUP,ITYPE,(IFFHDR(J),J=1,10)
      WRITE(IOUT6,89999)
      STOP 16
! NUMBER OF RECORDS READ/LOADED/UNLOADED DISAGREES WITH NUMBER EXPECTED
60200 WRITE(IOUT6,80200) IARCNO,ITYPE,IREC,NRECS
      WRITE(IOUT6,89999)
      STOP 16
! NUMBER OF WORDS READ/LOADED/UNLOADED DISAGREES WITH NUMBER EXPECTED
60220 WRITE(IOUT6,80220) IARCNO,ITYPE,NWORDS,IPTR,IPTSTR
      WRITE(IOUT6,89999)
      STOP 16
! INTEGER OR LOGICAL RECORD EXCEEDS BUFFER SPACE AVAILABLE
60300 WRITE(IOUT6,80300) IARCNO,ITYPE,IREC,NX,IFBUFR
      WRITE(IOUT6,89999)
      STOP 16
! FLOATING POINT CONVERSION PROBLEM
60350 WRITE(IOUT6,80350) ISTAT
      WRITE(IOUT6,89999)
      STOP 16
80150 FORMAT(1X,'BLOCK NUMBER,GROUP NUMBER OR TYPE IS INCORRECT ',      &
     & 13I5)
80200 FORMAT(1X,'NUMBER OF RECORDS READ/RELOADED DISAGREES WITH NUMBER',&
     &'EXPECTED. ARC NO.,RECORD TYPE,RECORD NUMBER, AND NO. OF RECORDS',&
     &'FOLLOWS'/5X,4I8)
80220 FORMAT(1X,'NUMBER OF WORDS READ/RELOADED DISAGREES WITH NUMBER',&
     &'EXPECTED. '/1X,'ARC NUMBER,RECORD TYPE,NUMBER OF WORDS,STARTING',&
     &'POINTER,AND ENDING POINTER FOLLOW'/1X,6I8)
80300 FORMAT(1X,'INPUT RECORD EXCEEDS BUFFER SPACE - (ARC NO.,RECORD',&
     &'TYPE,RECORD NUMBER,NO. OF WORDS,BUFFER SPACE )'/10X,5I8)
80350 FORMAT(1X,'FLOATING POINT CONVERSION PROBLEM - ISTAT = ',I5)
89999 FORMAT(1X,'EXECUTION TERMINATING IN SUBROUTINE IFRAD6 ')
      END
