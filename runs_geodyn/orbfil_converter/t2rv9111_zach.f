      PROGRAM TJTORV
C***********************************************************************
C
C    PURPOSE:  TO READ GEODYN TRAJECTORY FILE ON THE CRAY AND CONVERT
C              IT TO A FILE WHICH CAN BE USED ON THE 81.
C
C    MODIFICATION           07.06.90            LUCIA TSAOUSSI
C
C              READ THE FLAGGED DATA BUFFERS OUTPUT BY GEODYN II
C              AND PROPERLY ACCOUNT FOR THE LEAP SECONDS.
C    RESTRICTION : ONE LEAP SECOND PER BUFFER!
C
C           MODS FOR  CRAY  8/29/90             SHELLEY ROWTON
C           MODS FOR TOPEX EXTENDED VERSION OF THE TRAJECTORY FILE
C                          11/15/91             TERRY WILLIAMS
C
C    NOTE:     NTB - ACTUAL NUMBER OF POINTS IN THE BUFFER.
C              NTIMBF - MAXIMUM BUFFER SIZE. TO READ THE TRAJECTORY
C              DATA, ONE'S POINTER MUST BE OFFSET BY 5+2*NTIMBF.
C
C              PROGRAM WILL READ FOR ONLY ONE SATELLITE. UNIT 30
C              SHOULD BE SPECIFIED ON CALLING LINE, FOR EXAMPLE
C              UNIT30=TRAJCT WILL PICK UP THE OUTPUT FROM
C              GEODYN.  IF ANOTHER FILE NAME IS DESIRED, THEN IT
C              IT IS IMPORTANT TO NOTE THAT ONE WOULD USE FORTRAN 77
C              CONVENTIONS.
C
C              FOR PROCESSING OF MULTIPLE SATELLITES:
C              PROGRAM USES THE FOLLOWING INPUT FILES: FILE.31-FILE.49,
C              AND FILE.81-FILE.85. THIS WILL READ ALL 24 TRAJECTORY
C              FILES FOR EACH GPS SATELLITE.  NOTHING NEED BE SPECIFIED
C              ON THE CALLING LINE TO READ THESE UNITS.
C
C              CALLING LINE FOR PROGRAM WILL BE: TJRV9007.
C
C     OUTPUT FILES:  UNIT 20 - WRITTEN IN IBM 64-BIT FLOATING FORMAT
C                    UNIT 21 - WRITTEN IN CRAY 64-BIT FLOATING FORMAT
C
C***********************************************************************
      IMPLICIT REAL*8 (A-H,O-Z)                                         CVAX
      CHARACTER*7 FILEID
      CHARACTER*5 CFILE
      CHARACTER*1 NUMS(10),CNUM1,CNUM2
      LOGICAL FSTIME,LEXIST
      LOGICAL LEAPS
      DIMENSION DATBUF(2048),TRJDAT(18)
      DIMENSION RVDATA(22)
      DIMENSION IJYMD(1),IJHM(1),XSEC(1),FSECU(1)
      DATA N10/10/N22/22/,ICNT/0/,KCNT/0/,SMLNUM/.4/,KSATRQ/1/
      DATA IOUT/6/,MSAT/25/,NMAX/18/,MAXDAT/22/
      DATA PI/3.141592653589793D0/
      DATA CFILE/'FILE.'/
      DATA ZERO/0.0D0/
      DATA NUMS/'0','1','2','3','4','5','6','7','8','9'/
CGEN  DFLOAT
C     KSATRQ = KTH SATELLITE ON TRAJECTORY FILE IS TO BE WRITTEN IN
C               GEODYN I  RV FORMAT
C
C     READ HEADER BUFFER
C
CCC   OPEN(6,FILE='OUT06')
CC    OPEN(20,FILE='RVOUT')
C
C *** INITIALIZE VARIBLES
      IUNIT = 29
C      RAD2DG = 180.0E0/PI
      RAD2DG = 180.0D0/PI
      DO 50 I = 1,NMAX
         TRJDAT(I) = ZERO
   50 CONTINUE
C *** LOOP FOR THE MAXIMUM NUMBER OF SATELLITES THAT CAN BE IN
C *** ANY GEODYN RUN..  CHECK FOR THE EXISTANCE OF THE FILE, THEN
C *** OPEN THE FILE ONLY IF IT EXISTS.
      ICNT = 0
      DO 2000 NSAT = 1,MSAT
      IUNIT = IUNIT+1
      IF(IUNIT.EQ.30) GO TO 100
      IF(IUNIT.GT.49) THEN
        ICNT = ICNT+1
        IUNIT = 80+ICNT
      ENDIF
C     WRITE(6,98702) IUNIT
C8702 FORMAT(' IUNIT ',I5)
      NUM1 = IUNIT/10+1
      CNUM1 = NUMS(NUM1)
      NUM2 = IUNIT-(NUM1-1)*10+1
      CNUM2 = NUMS(NUM2)
      FILEID = CFILE//CNUM1//CNUM2
C     WRITE(6,98703) CFILE,IUNIT,FILEID
C8703 FORMAT(' CFILE IUNIT FILEID ',A5,2X,I2,2X,A7)
      INQUIRE(FILE=FILEID,EXIST=LEXIST)
      IF(.NOT.LEXIST) GO TO 1000
  100 CONTINUE
C     WRITE(6,*) 'IUNIT = ', IUNIT
      READ(IUNIT,END=1000) DATBUF
C     WRITE(6,*) 'DATBUF = ', DATBUF
      NBUF=DATBUF(2)
      NSATS=DATBUF(7)
      NWDSAT=DATBUF(8)
      NTIMBF=DATBUF(10)
      SATID=DATBUF(301)
      WRITE(6,9014) NSATS,NWDSAT
      WRITE(6,1500)
      ICOUNT=0
      FSTIME=.TRUE.
C
C     READ ALPHANUMERIC BUFFERS
C     WRITE(6,*) 'NBUF = ', NBUF
      DO 200 I=1,NBUF
      READ(IUNIT) DATBUF
      IF(I.EQ.1) THEN
         VERIIS = DATBUF(5)
         VERIIE = DATBUF(6)
      ENDIF
      IF(ABS(DATBUF(1) - (-8.0E9) ) .GT. .01 ) THEN
         WRITE(6,1600)
         GOTO 310
      ENDIF
  200 CONTINUE
      WRITE(6,1600)
C
C     READ DATA BUFFERS
  300 CONTINUE
      READ(IUNIT,END=550) DATBUF
  310 CONTINUE
      IF(DATBUF(1).GE.8.0D9) GOTO 500
      ICOUNT=ICOUNT+1
C     WRITE(6,1700) ICOUNT
C
C     INTERPRET DATA
C
C USE THE BUFFER FLAG TO SET UP THE LEAP SECOND LOGICAL
      IBFCNT=DATBUF(1)
      TEST=DATBUF(1)-IBFCNT
      IF (TEST.EQ.0.5D0) LEAPS=.TRUE.
C GET INTEGER UTC SECONDS SINCE 2430000.5 AND FRACTIONAL
C  REMAINING SECONDS FOR FIRST DATA POINT
      STUTM1=DATBUF(2)
      STUTM2=DATBUF(3)
      NTB   =DATBUF(5)
C *** NO LONGER USING NTBOLD, CORRECTION AS OF 11/6/89
C     IF(NTBOLD.EQ.0) NTBOLD=NTB
      YMD=STUTM1/1.D6
      IYMD=YMD+SMLNUM
      HMS=MOD(STUTM1,1.D6)
      IHMS=HMS+SMLNUM
      CALL YMDTIS(IYMD,IHMS,MJDSCU)
      IADD=STUTM2
      XADD=DFLOAT(IADD)
      FSECU(1)=STUTM2-XADD
      MJDSCU=MJDSCU+IADD
C GET THE DELTA ET TIME FOR THIS BLOCK; USE THIS ALSO AS
C  THE DELTA UTC TIME & DELTA A1 TIME
      DELTAS=DATBUF(7)-DATBUF(6)
      DELTAD=DELTAS/86400.D0
C GET INTEGER SECONDS TO JAN 0.0 OF REF YEAR
C THIS SECTION OF CODE WAS MODIFIED 11/6/89 BY WILLIAMS AND EDDY
C TO FORCE THE OUTPUT A1 TIME TO ALWAYS INCREASE.  PREVIOUSLY
C THE A1 TIME WAS RESET AT THE START OF EACH YEAR.
      IF (FSTIME) THEN
        IREFYR=(IYMD/10000)*10000+100
        CALL YMDTIS(IREFYR,0,ISCFJD)
      ENDIF
C GET DAYS FROM JAN 0.0 OF REF YEAR TO FIRST A1 TIME
C  (USE ET-A1=32.1496183)
      ISECET=DATBUF(4)+SMLNUM
      ISECET=ISECET-ISCFJD
      ISECA1=ISECET-33
      FSECA1=DATBUF(6)+.8503817D0
      IDAYA1=ISECA1/86400
      ISECA1=ISECA1-IDAYA1*86400
      DAYA1=DFLOAT(IDAYA1)+(DFLOAT(ISECA1)+FSECA1)/86400.D0
C
      DO 490 IPNT=1,NTB
C
      CALL YMDHMS(MJDSCU,FSECU,IJYMD,IJHM,XSEC,1)
      DAYA1O=DAYA1
C
C   SUBTRACT THE LEAP SECOND AT THE APPROPRIATE TIME OF YEAR
      IF (.NOT.LEAPS) GO TO 400
      IJMD=MOD(IJYMD(1),10000)
      IF (IJMD.EQ.101.OR.IJMD.EQ.701) THEN
         FSECU(1)=FSECU(1)-1.0D0
         CALL YMDHMS(MJDSCU,FSECU,IJYMD,IJHM,XSEC,1)
         LEAPS=.FALSE.
      END IF
 400  CONTINUE
C *** GET GREENWICH HOUR ANGLE
      TRJDAT(NMAX) = DATBUF(NTIMBF+5+IPNT)*RAD2DG
      MMM = NMAX-1
      DO 450 I=1,MMM
      TRJDAT(I)=DATBUF(2*NTIMBF+5+I+((IPNT-1)*NSATS+(KSATRQ-1))*NWDSAT)
  450 CONTINUE
C
C     WRITE HEADER RECORD AND DATA POINTS
C
      FSECU(1)=FSECU(1)+DELTAS
      DAYA1=DAYA1+DELTAD
  460 CONTINUE
      RVDATA(1) = DAYA1O
      RVDATA(2) = DFLOAT(IJYMD(1))
      RVDATA(3) = DFLOAT(IJHM(1))
      RVDATA(4) = XSEC(1)
C     WRITE(6,9910) (RVDATA(I),I=1,4)
9910  FORMAT(1X,4E22.12)
      DO 465 II = 1,NMAX
      RVDATA(II+4)=TRJDAT(II)
  465 CONTINUE
C
C        COUNT DATA RECORDS
C
      ICNT=ICNT+1
         WRITE(20) RVDATA
C         WRITE IDENTICAL HEADER AND FIRST DATA POINT
      IF(.NOT.FSTIME) GOTO 490
      FSTIME=.FALSE.
      GOTO 460
  490 CONTINUE
      GOTO 300
C
  500 CONTINUE
      WRITE(6,1009)
C WRITE END FLAG = 999.0E0  AND CONVERT TO IBM FORMAT
C CODE IS CHANGED HERE TO ZERO OUT REMAINDER OF SENTINEL RECORD
C AS OF 11/9/89 BY WILLIAMS AND EDDY
       RVDATA(1)=999.0D0
       RVDATA(2)=SATID
       RVDATA(3) = VERIIS
       RVDATA(4) = VERIIE
       DO 525 IEND = 5,MAXDAT
         RVDATA(IEND) = ZERO
  525  CONTINUE
       ISATID = SATID
       WRITE(6,80000) IUNIT,ISATID
         WRITE(20) RVDATA
       GO TO 2001
 1000  CONTINUE
C       WRITE(6,98701) IUNIT
C98701 FORMAT(' THE FOLLOWING UNIT DOES NOT EXIST ',I5)
 2000  CONTINUE
 2001  CONTINUE
C
C        NORMAL END OF JOB
C
        WRITE(6,90100) ICNT
C
C        WRITE NUMBER OF TIMES STATUS WORD NOT EQUAL TO ZERO ENCOUNTERED
C
      WRITE(6,90150) KCNT
      GOTO 999
  550 CONTINUE
      WRITE(6,90205)
      GOTO 999
C
C *** I/O ERROR IN OPENING OF TRAJECTORY FILE
C
C9000 CONTINUE
C     WRITE(6,85000) IUNIT
C     STOP 16
C
C        ABNORMAL END OF JOB
C
 9900 CONTINUE
      WRITE(6,90200)
      STOP 16
  999 CONTINUE
 1009 FORMAT(1X,'REACHED SENTINEL DATA')
 1500 FORMAT(1X,'READ HEADER BUFFER')
 1600 FORMAT(1X,'READ ALPHANUMERIC BUFFERS')
 1700 FORMAT(//1X,'READ DATA BUFFER NUMBER ',I5)
 9013 FORMAT(' LATITUDE AND LONGITUDE ARE ON INPUT RV TAPE')
 9014 FORMAT(1X,'NSATS, NWDSAT = ',2I5)
80000 FORMAT(' *** THE SATELLITE ID FROM UNIT ',I2,' IS ',I8)
90000 FORMAT(1X,'CRAY VALUES OVERFLOWED IN THE CONVERSION OF REAL NOS')
90100 FORMAT(1X,'NORMAL END OF JOB - ',I8,'RECORDS OUTPUT')
90150 FORMAT(1X,I8,'RECORDS RETURNED WITH STATUS WORD NOT EQUAL TO 0')
90200 FORMAT(1X,'ABNORMAL END OF JOB - EXECUTION TERMINATING')
90205 FORMAT(1X,'REACHED END OF DATA WITHOUT SENTINEL BUFFER')
      END
      SUBROUTINE YMDHMS(MJDS,FSEC,IYMD,IHM,SEC,NPTS)
C***********************************************************************
C
C    PURPOSE:
C
C     NAME     I/O     DESCRIPTION
C     ----------------------------
C     MJDS             MODIFIED JULIAN DAY SECONDS
C     FSEC             FRACTION OF A SECOND
C     IYMD             YEAR,MONTH,DAY IN FORM YYMMDD
C     IHM              HOUR,MINUTE IN FORM HHMM
C     SEC              SECONDS IN FORM SS.SSS
C     NPTS             NUMBER OF POINTS
C
C***********************************************************************
      IMPLICIT REAL*8 (A-H,O-Z)                                         CVAX
      IMPLICIT LOGICAL (L)
      DIMENSION FSEC(NPTS),IYMD(NPTS),IHM(NPTS),SEC(NPTS)
      DATA IYMDRF/410106/
      DATA SECMIN/6.0D1/,SECDAY/86400.D0/
CGEN DFLOAT
C COMPUTE MODIFIED JULIAN DAY = JULIAN DAY - 2430000.5
      MJD=(DFLOAT(MJDS)+FSEC(1))/SECDAY
C ADD ELAPSED DAYS SINCE JD 2430000.5 TO REFERENCE CALENDAR DATE
      IYMD0=IYMDRF
      CALL ADDYMD(IYMD0,MJD)
C COMPUTE START TIME ELAPSED SECONDS WITHIN DAY
      ISEC0=MJDS-MJD*86400
      SEC0=DFLOAT(ISEC0)
C ADD TO ELAPSED SECONDS SINCE START TIME
C     SEC(1;NPTS)=SEC0+FSEC(1;NPTS)
      DO 10 I=1,NPTS
      SEC(I)=FSEC(I)+SEC0
   10 CONTINUE
C COMPUTE INTEGRAL ELAPSED DAYS FROM START DATE
C     IYMD(1;NPTS)=SEC(1;NPTS)/SECDAY
      DO 20 I=1,NPTS
      IYMD(I)=SEC(I)/SECDAY
   20 CONTINUE
C SUBTRACT INTEGRAL DAYS FROM ELAPSED SECONDS
C     SEC(1;NPTS)=SEC(1;NPTS)-IYMD(1;NPTS)*86400
      DO 30 I=1,NPTS
      SEC(I)=SEC(I)-IYMD(I)*86400
   30 CONTINUE
C COMPUTE INTEGRAL ELAPSED MINUTES WITHIN DAY
C     IHM(1;NPTS)=SEC(1;NPTS)/SECMIN
      DO 40 I=1,NPTS
      IHM(I)=SEC(I)/SECMIN
   40 CONTINUE
C SUBTRACT INTEGRAL MINUTES FROM ELAPSED SECONDS
C     SEC(1;NPTS)=SEC(1;NPTS)-IHM(1;NPTS)*60
      DO 50 I=1,NPTS
      SEC(I)=SEC(I)-IHM(I)*60
   50 CONTINUE
C CONVERT INTEGRAL MINUTES TO HOURS AND MINUTES
C     IH=IHM(N)/60
C     IHM(N)=IHM(N)-IH*60
C     IHM(N)=IHM(N)+IH*100
C     IHM(1;NPTS)=(IHM(1;NPTS)/60)*40+IHM(1;NPTS)
      DO 60 I=1,NPTS
      IHM(I)=(IHM(I)/60)*40+IHM(I)
   60 CONTINUE
C REPLACE INTEGRAL DAYS SINCE START DATE WITH CALENDAR DATE
      IDAYS=0
      IYMDAY=IYMD0
      DO 8000 N=1,NPTS
      IF(IYMD(N).EQ.IDAYS) GO TO 7000
      IDAYS=IYMD(N)
      IYMDAY=IYMD0
      CALL ADDYMD(IYMDAY,IDAYS)
 7000 CONTINUE
      IYMD(N)=IYMDAY
 8000 CONTINUE
      RETURN
      END
      SUBROUTINE ADDYMD(IYMD,IDAY)
C***********************************************************************
C
C    PURPOSE:
C
C     NAME     I/O     DESCRIPTION
C     ----------------------------
C     IYMD             YEAR,MONTH,DAY IN FORM YYMMDD
C     IDAY             NUMBER OF DAYS
C
C***********************************************************************
      IMPLICIT LOGICAL (L)
      DIMENSION MONTH(13,2)
      DATA MONTH/0,31,60,91,121,152,182,213,244,274,305,335,366,
     1           0,31,59,90,120,151,181,212,243,273,304,334,365/
      IY=IYMD/10000
      IK=IY*10000
      IM=(IYMD-IK)/100
      ID=IYMD-IK-IM*100
      ILEAPY=MOD(IY,4)
      ILEAPY=MIN0(ILEAPY,1)+1
      ID=((IY-1)*36525)/100+MONTH(IM,ILEAPY)+ID+IDAY
      IY=((ID-1)*100)/36525+1
      ID=ID-(36525*(IY-1))/100
      ILEAPY=MOD(IY,4)
      ILEAPY=MIN0(ILEAPY,1)+1
      IF(ILEAPY.EQ.1.OR.ID.LT.366) GO TO 500
      IY=IY+1
      ID=ID-365
      ILEAPY=MOD(IY,4)
      ILEAPY=MIN0(ILEAPY,1)+1
  500 CONTINUE
      DO 1000 I=1,12
      IF(ID.GT.MONTH(I+1,ILEAPY)) GO TO 1000
      IM=I
      GO TO 2000
 1000 CONTINUE
 2000 CONTINUE
      IYMD=IY*10000+IM*100+ID-MONTH(IM,ILEAPY)
      RETURN
      END
C$
      SUBROUTINE YMDTIS(IYIMID,IHIMIS,ISEC)
C*********************************************************************SA
C   VERSION           DATE 11/30/82     PGMR D. ROWLANDS
C   FUNCTION         CALCULATE THE INTEGER NUMBER OF UT SECONDS
C                    SINCE JD 2430000.5D0 TO
C                    TIME IYIMID,IHIMIS
C
C
C   INPUT PARAMETER  IYIMID- REFERENCE DATE
C                    IHIMIS- REFERENCE TIME
C   OUTPUT PARAMETER ISEC-INTEGER UT SECONDS FROM JD 243000.5 TO
C                         TIME IYIMID IHIMIS
C
C   RESTRICTIONS     DATE MUST BE IN 20TH CENTURY
C********************************************************************
      IMPLICIT REAL*8(A-H,O-Z),LOGICAL(L)                               CVAX
      DIMENSION MONTAB(24)
      DATA MONTAB/0,31,59,90,120,151,181,212,243,273,304,334,
     .            0,31,60,91,121,152,182,213,244,274,305,335/
C
C**********************************************************************
C START OF EXECUTABLE CODE ********************************************
C**********************************************************************
C
      IADD=0
      IYR=IYIMID/10000
      IYR4=(IYR+3)/4
      IJD=365*IYR+IYR4
      IMO=MOD(IYIMID,10000)
      IMO=IMO/100
      IF(MOD(IYR,4).EQ.0) IADD=12
      IJD=IJD+MONTAB(IMO+IADD)
      ID=MOD(IYIMID,100)
      IJD=IJD+ID+2415018
      IH=IHIMIS/10000
      IM=IHIMIS-IH*10000
      IM=IM/100
      IS=MOD(IHIMIS,100)
      ISEC=(IJD-2430000)*86400+IH*3600+IM*60+IS
      RETURN
      END
      SUBROUTINE MOVEBUF(IN,OUT,N)
C
C  ********************************************************************
C  *                                                                  *
C  *         MOVES A REAL ARRAY TO A DOUBLE PRECISION ARRAY           *
C  *                                                                  *
C  ********************************************************************
C
      REAL IN
      DOUBLE PRECISION OUT
C
      DIMENSION IN(22), OUT(22)
C
      DO 10 I = 1, N
         OUT(I) = IN(I)
   10 CONTINUE
C
      RETURN
      END
